/*
    Portions of this file are derived from the Rust standard library
    (std::io), originally licensed under the MIT license.

    Copyright (c) The Rust Project Constributors

    Licensed under the MIT License. A copy is provided in `/LICENSE`.

    Modifications (if any) are Copyright (c) 2026 John Isaac Calderon
*/

/*!
    Platform-agnostic exposure of I/O operations

    This module defines the contract between
    platform-agnostic users and platform-specific
    providers.

    This module aspires to be a minimal stand-in for `std::io`;
    it attempts to offer identical usage and functionality wherever
    it is feasible and appropriate.
*/

use core::fmt;

/* Helper methods */

/// Fallback formatting method for [`Write::write_fmt`](Write::write_fmt)
pub(crate) fn default_write_fmt<'a, W: Write + ?Sized + 'a>(
    this: &'a mut W,
    args: fmt::Arguments,
) -> Result<(), Error> {
    /* Just do what `default_write_fmt` in `std` does... */

    // Create a shim that implements `fmt::Write`, and then
    // take its output, propagating errors in the process
    struct FmtShim<'a, T: Write + ?Sized + 'a> {
        inner: &'a mut T,
        error: Result<(), Error>,
    }

    impl<'a, T: Write + ?Sized + 'a> fmt::Write for FmtShim<'_, T> {
        fn write_str(&mut self, s: &str) -> Result<(), fmt::Error> {
            // Save error from `Write`, then generate an error
            // signal that `fmt::Write::write_str` expects
            match self.inner.write_all(s.as_bytes()) {
                Ok(()) => Ok(()),
                Err(e) => {
                    self.error = Err(e);
                    Err(fmt::Error)
                }
            }
        }
    }

    // Instantiate adapter, then use `fmt::write` to
    // write indirectly to `self`
    let mut adapter = FmtShim {
        inner: this,
        error: Ok(()),
    };

    // - generate error signal as expected by this function
    // TODO: fix semantics
    match fmt::write(&mut adapter, args) {
        Ok(()) => Ok(()),
        Err(..) => {
            // - check whether the error was generated by `self.write_all`
            if adapter.error.is_err() {
                adapter.error
            } else {
                // - unlike `std`, we're actually gonna return
                // something, rather than panicking outright
                Err(Error::E_UNCATEGORIZED)
            }
        }
    }
}

/*
    Shared traits that define contracts between
    platform-agnostic users and platform-specific
    providers

    These traits define the contract for specific
    I/O operations, which implementors must comply
    with.

    As per decision 2025-08-30, part 2, platform-specific
    definitions must be separated from shared defintions,
    and must be guarded off whenever possible.

    TODO: finish doc-comments and reword, so that we aren't using
    the exact same wording as the Rust standard library (though
    this is mostly a legal detail, and not a functional one)
*/

/*
    Error kinds that faithfully emulates `std::io::ErrorKind`
    to the extent permitted by `no_std`.

    This may be expanded as internal use grows.
*/
#[derive(Debug, Copy, Clone)]
#[non_exhaustive]
pub enum ErrorKind {
    /* Error kinds that require a working OS */
    /// Resource not found
    NotFound,

    /// Insufficient privileges for the requested action
    PermissionDenied,

    /// Resource busy
    ResourceBusy,

    /* Conceptual errors */
    /// Invalid input parameters
    InvalidInput,

    /// Invalid data encountered
    InvalidData,

    /// Unexpected end-of-file
    UnexpectedEof,

    /// Action interrupted
    ///
    /// Use only if retrying is idempotent and safe
    Interrupted,

    /// Action is expected to block
    WouldBlock,

    /// Action currently in progress
    InProgress,

    /// Action timed out
    TimedOut,

    /// Insufficient memory for requested action
    OutOfMemory,

    /// Unsupported requested action
    Unsupported,

    /// Zero bytes written
    WriteZero,

    /// Resource uninitialized
    Uninitialized,

    /// Other error
    Other,

    /// Uncategorized error
    Uncategorized,
}

/*
    A fixed set of error payload types

    This is pretty much the only legal way we can have
    "dynamic typing" in a `no_std` environment.
*/
#[derive(Debug, Copy, Clone)]
#[non_exhaustive]
pub enum ErrorPayload {
    Code(usize),
    Message(&'static str),
    Other,
    Empty,
}

/*
    Structure that represents an error, and faithfully emulates
    `std::io::Error` to the extent permitted by `no_std`.

    As we can't assume that dynamic typing will be available,
    we're gonna have to be creative...
*/
#[derive(Debug)]
pub struct Error {
    e_kind: ErrorKind,
    e_payload: ErrorPayload,
}

// macro to rapidly define zero-payload errors
// syntax: `$e_name => $e_kind,`
macro_rules! error_define {
    ($e_name:ident => $e_kind:ident, $($rest:tt)*) => {
        pub const $e_name: Error = Error {
            e_kind: ErrorKind::$e_kind,
            e_payload: ErrorPayload::Empty,
        };

        error_define! { $($rest)* }
    };

    ($e_name:ident => $e_kind:ident) => {
        pub const $e_name: Error = Error {
            e_kind: ErrorKind::$e_kind,
            e_payload: ErrorPayload::Empty,
        };
    };

    () => {}
}

// macro to rapidly instantiate `Err(Error)`
// syntax:
// - `error!(ErrorKind)`
// - `error!(other ErrorKind)`
// - `error!(ErrorKind, ErrorPayload, literal)`
macro_rules! error {
    ($e_kind:ident) => {
        Err(Error {
            e_kind: ErrorKind::$e_kind,
            e_payload: ErrorPayload::Empty,
        })
    };

    (other $e_kind:ident) => {
        Err(Error {
            e_kind: ErrorKind::$e_kind,
            e_payload: ErrorPayload::Other,
        })
    };

    ($e_kind:ident, $p_type:ident, $p_content:expr) => {
        Err(Error {
            e_kind: ErrorKind::$e_kind,
            e_payload: ErrorPayload::$p_type($p_content),
        })
    };
}

impl Error {
    /// Create an `Error` with provided kind and payload
    pub const fn new(kind: ErrorKind, payload: ErrorPayload) -> Self {
        Error {
            e_kind: kind,
            e_payload: payload,
        }
    }

    /// Return error kind
    pub fn kind(&self) -> ErrorKind {
        self.e_kind
    }

    /// Return error payload
    pub fn payload(&self) -> ErrorPayload {
        self.e_payload
    }

    /* Zero-payload error types */
    error_define! {
        E_NOT_FOUND => NotFound,
        E_PERMISSION_DENIED => PermissionDenied,
        E_RESOURCE_BUSY => ResourceBusy,
        E_INVALID_INPUT => InvalidInput,
        E_INVALID_DATA => InvalidData,
        E_UNEXPECTED_EOF => UnexpectedEof,
        E_INTERRUPTED => Interrupted,
        E_WOULD_BLOCK => WouldBlock,
        E_IN_PROGRESS => InProgress,
        E_TIMED_OUT => TimedOut,
        E_OUT_OF_MEMORY => OutOfMemory,
        E_UNSUPPORTED => Unsupported,
        E_WRITE_ZERO => WriteZero,
        E_UNINITIALIZED => Uninitialized,
        E_OTHER => Other,
        E_UNCATEGORIZED => Uncategorized,
    }
}

/**
    Trait to mark type as readable

    Implementors of `Read` are called "readers".

    Readers are defined by one required method [`read`](Read::read). Each call
    to `read()` will attempt to pull bytes from this source into a provided buffer.
    A number of methods are implemented in terms of `read()`, giving implementors
    a number of ways to read bytes while only implementing a single method.
*/
pub trait Read {
    /**
        Pull some bytes from this source into the specified
        buffer, returning how many bytes were read.

        This function does not provide any guarantees about whether it
        blocks waiting for data, but if an object needs to block for a
        ead and cannot, it will typically signal this via an `Err`
        return value.

        If the return value of this method is `Ok(n)`, then implementations
        must guarantee that `0 <= n <= buf.len()`. A non-zero value for `n`
        indicates that the buffer `buf` has been filled in with `n` bytes of
        data from this source. If `n` is 0, then it can indicate one of two
        scenarios:

        - This reader has reached its “end of file” and will likely no longer
        be able to produce bytes. Note that this does not mean that the reader
        will always no longer be able to produce bytes.
        - The buffer specified was 0 bytes in length.

        # Errors
        If this function encounters any form of I/O or other error, an error of
        the type `ReadError` will be returned. If an error is returned then it
        must be guaranteed that no bytes were read.

        It is **not** an error if the returned value is smaller than the buffer size,
        even when the reader is not at the end of the stream yet. This may happen for
        example because fewer bytes are actually available right now (e. g. being close
        to end-of-file) or because `read()` was interrupted.

        # Safety
        As this trait is safe to implement, callers in unsafe code cannot rely on
        `n <= buf.len()` for safety. Extra care needs to be taken when unsafe functions
        are used to access the read bytes. Callers have to ensure that no unchecked
        out-of-bounds accesses are possible even if `n > buf.len()`.
    */
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, Error>;

    /* Given implementations */

    /**
        Reads the exact number of bytes required to fill `buf`.

        This function reads as many bytes as necessary to
        completely fill the specified buffer `buf`.

        # Errors
        If this function returns an error, it is unspecified how many
        bytes it has read, but it will never read more than would be
        necessary to completely fill the buffer.
    */
    // FIXME: find a mathematically better and safer alternative
    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<(), Error> {
        /* Just do what the standard library does... */

        // Keep reading until there is no region left untouched
        while !buf.is_empty() {
            // Attempt to read into what appears to be
            // untouched regions of the provided buffer
            match self.read(&mut buf) {
                Ok(0) => {
                    // - unexpected EOF
                    return error!(UnexpectedEof, Message, "failed to fill the whole buffer");
                }
                Ok(m) => {
                    // - clamp `m`
                    let n = m.min(buf.len());

                    // - shrink `buf` rightward
                    buf = &mut buf[n..];
                }
                Err(e) => {
                    // - propagate generated error
                    return Err(e);
                }
            }
        }

        Ok(())
    }

    // TODO
}

/**
    Trait to mark type as writeable. Not to be confused with [`core::fmt::Write`].

    Implementors of the `Write` trait are sometimes called "writers".

    Writers are defined by two required methods: [`write`] and [`flush`](Write::flush):
    - The `write` method will attempt to write some data into the
    object, returning how many bytes were successfully written.
    - The `flush` method is useful for adapters and explicit buffers
    themselves for ensuring that all buffered data has been pushed
    out to the "true sink".

    [`core::fmt::Write`]: core::fmt::Write
    [`write`]: Write::write
*/
pub trait Write {
    /**
        Writes the provided buffer into this writer,
        returning how many bytes were written.

        This function will attempt to write the entire contents of `buf`,
        but the entire write might not succeed, or the write may also
        generate an error. Typically, a call to `write` represents one
        attempt to write to any wrapped object.

        # Errors
        Each call to `write` may generate an I/O error indicating that the
        operation could not be completed. If an error is returned then no
        bytes in the buffer were written to this writer.

        It is **not** considered an error if the entire buffer could not
        be written to this writer.

    */
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;

    /**
        Flushes this output stream, ensuring that all intermediately
        buffered contents reach their destination.

        # Errors
        It is considered an error if not all bytes could be written
        due to I/O errors or EOF being reached.
    */
    fn flush(&mut self) -> Result<(), Error>;

    /* Given implementations */

    /// Attempts to write an entire buffer into this writer.
    // TODO: make it smarter!
    fn write_all(&mut self, mut buf: &[u8]) -> Result<(), Error> {
        /* Just do what the standard library does... */

        // Keep reading until there is no region left unseen
        while !buf.is_empty() {
            // Attempt to write from what appears to be
            // unseen regions of the provided buffer
            match self.write(&buf) {
                Ok(0) => {
                    // - unexpected EOF
                    return error!(WriteZero, Message, "failed to consume the whole buffer");
                }
                Ok(m) => {
                    // - clamp `m`
                    let n = m.min(buf.len());

                    // - shrink `buf` rightward
                    buf = &buf[n..];
                }
                Err(e) => {
                    // - propagate generated error
                    return Err(e);
                }
            }
        }

        Ok(())
    }

    /// Write formatted string
    // - adapter for the macro `write!`
    // - must not be confused with `core::fmt::Write::write_fmt`
    // TODO: make this smarter!
    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> Result<(), Error> {
        default_write_fmt(self, args)
    }
}
